#!/bin/bash
# Other tools (mostly external) functions file for airoscript.

# Copyright (C) 2009-2011 David Francos Cuartero
#        This program is free software; you can redistribute it and/or
#        modify it under the terms of the GNU General Public License
#        as published by the Free Software Foundation; either version 2
#        of the License, or (at your option) any later version.

#        This program is distributed in the hope that it will be useful,
#        but WITHOUT ANY WARRANTY; without even the implied warranty of
#        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#        GNU General Public License for more details.

#        You should have received a copy of the GNU General Public License
#        along with this program; if not, write to the Free Software
#        Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
check_function fakeauth3 || source $path/attacks/auth # It depends on auth module ;)

othertmenu(){
    while true; do
         mkmenu "Other aircrack-ng tools" "Injection" "Autentication" "Operations with ivstools" "Decloak packages" "Create virtual interface with airtun-ng" "Diagnostics and reports" "Auto crack wep with wesside-ng" "Easside-ng" "Return to main menu"
        case $choice in
            1  ) injectmenu    ; $clear; break;;
            2  ) authmenu      ; $clear; break;;
            3  ) ivstoomenu    ; $clear; break;;
            4  ) airdecmenu    ; $clear; break;;
            5  ) airtunmenu    ; $clear; break;;
            6  ) diagmenu      ; $clear; break;;
            7  ) choosewesside ; $clear; break;;
            8  ) eassideng     ; $clear; break;;
            9  ) $clear        ; break ;;
            *  ) _ "Unknown response, try again"; sleep 1; $clear;;
        esac
    done
}

airdecmenu(){
    while true; do
        if [ "$d_cloaked_null" == 1 ]; then d_cloaked_null_status="X"; else d_cloaked_null_status=" "; fi
        if [ "$d_cloaked_base" == 1 ]; then d_cloaked_base_status="X"; else d_cloaked_base_status=" "; fi
        if [ "$d_cloaked_frag" == 1 ]; then d_cloaked_frag_status="X"; else d_cloaked_frag_status=" "; fi

        mkmenu "Airdecloak-ng" "Asume that null packets can be cloacked [$d_cloaked_null_status]" "Disable base filter [$d_cloaked_base_status]" "Drop fragmented packets [$d_cloaked_frag_status]" "Specify filters (comma separated)" "Launch decloak" "Return to main menu"
        opts="";
        case $choice in
            1) if [ "$d_cloaked_null" == 1 ]; then d_cloaked_null=0; else d_cloaked_null=1; fi; $clear;;
            2) if [ "$d_cloaked_base" == 1 ]; then d_cloaked_base=0; else d_cloaked_base=1; fi; $clear;;
            3) if [ "$d_cloaked_frag" == 1 ]; then d_cloaked_frag=0; else d_cloaked_frag=1; fi; $clear;;
            4) single_question "Enter filters: "; d_cloaked_filters=$ans; $clear;;
            5)
                if [ "$d_cloaked_null" == 1 ]; then opts="$opts --null-packets"; fi
                if [ "$d_cloaked_base" == 1 ]; then opts="$opts --diable-base-filter"; fi
                if [ "$d_cloaked_frag" == 1 ]; then opts="$opts --drop-frag"; fi
                execute $AIRDECLOAK $opts --ssid $Host_SSID --bssid $Host_MAC --filters $d_cloaked_filters -i $DUMP_PATH/$Host_MAC-01.cap 
                $clear; break;;
            6) $clear; break;;
        esac
    done
}

airtunmenu(){
    if [ "$Host_MAC" != "" ] && [ "$Host_SSID" != "" ] && [ -e $DUMP_PATH/$Host_MAC.key ]; then
        _ "Creating virtual interface" && sleep 2
        $AIRTUN -a $Host_MAC -i $wificard -w "`cat $DUMP_PATH/$Host_MAC.key`"
        _ "Take note of the created virtual interface"; sleep 2; $clear; return
    else
        $clear; warn "You don't have a cracked WEP interface"; sleep 2; $clear; return
    fi
}

ivstoomenu(){
    while true; do
        mkmenu "IVs tools" "Merge all ivs from all sessions" "Decrypt current packages"\
            "Return to main menu"
        case $choice in
            1) mergeallivs;$clear; break;;
            2) decrypt; $clear; break;;
            3 ) $clear;break ;;
            * ) _ "Unknown response. Try again" ;;
        esac
    done
}

mergethisivs(){ # TODO Untested
    for i in $DUMP_PATH/$Host_MAC*.cap; do 
        cur=$( $cur + `$IVSTOOLS --convert $i /dev/null|grep IVs|awk '{print $2}'`)
    done
    return $cur
}

mergeallivs(){ # TODO Untested
    newdir=`mktemp -d`
    for i in $TMPDIR/*/*.cap; do b=$(( $b + 1 )); $IVSTOOLS --convert $i $newdir/$b; done
    ivstools --merge $newdir/* $DUMP_PATH/merged.cap
    read -p "`gettext 'Select merged data as target? (y/N): '`" ACP && [[ "$ACP" = "y" ]] && Host_MAC="merged"
}




choosewesside(){
        while true; do
            $clear; mkmenu "Choose Wesside-ng Options" "No args" "Selected target" "Sel. target max retrans" "Sel. target poor conection" "Select another target" "Return to main menu"
            read yn;
            case $yn in
                1 ) wesside ; break ;;
                2 ) wessidetarget ; break ;;
                3 ) wessidetargetmaxer ; break ;;
                4 ) wessidetargetpoor ; break ;;
                5 ) wessidenewtarget ; break ;;
                6 ) break ;;
                * ) echo -e "`gettext \"Unknown response. Try again\"`" ;;
            esac
    done
}

wesside(){
    rm -rf prga.log wep.cap key.log
    execute "Wesside-ng" $WESSIDE -i $wifi & choosewesside
}

wessidetarget(){
    rm -rf prga.log wep.cap key.log
    execute "Wesside-ng" $WESSIDE -v $Host_MAC -i $wifi & choosewesside
}

wessidetargetmaxer(){
    rm -rf prga.log wep.cap key.log
    execute "Wesside-ng" $WESSIDE -v $Host_MAC -k 1 -i $wifi & choosewesside
}

wessidetargetpoor(){
    rm -rf prga.log wep.cap key.log
    execute "Wesside-ng" $WESSIDE -v $Host_MAC -k 3 -i $wifi & choosewesside
}

wessidenewtarget(){
    rm -rf prga.log wep.cap  key.log
    ap_array=`cat $DUMP_PATH/dump-01.csv | grep -a -n Station | awk -F : '{print $1}'`
    head -n $ap_array $DUMP_PATH/dump-01.csv &> $DUMP_PATH/dump-02.csv && $clear && i=0
    echo -e "`gettext\"        Detected Access point list\"`"
    echo -e "\n #      MAC                      CHAN    SECU    POWER   #CHAR   SSID\n"
    while IFS=, read MAC FTS LTS CHANNEL SPEED PRIVACY CYPHER AUTH POWER BEACON IV LANIP IDLENGTH ESSID KEY;do
        longueur=${#MAC}
        if [ $longueur -ge 17 ]; then
            i=$(($i+1))
            echo -e " "$i")\t"$MAC"\t"$CHANNEL"\t"$PRIVACY"\t"$POWER"\t"$IDLENGTH"\t"$ESSID
            aidlenght=$IDLENGTH
            assid[$i]=$ESSID
            achannel[$i]=$CHANNEL
            amac[$i]=$MAC
            aprivacy[$i]=$PRIVACY
            aspeed[$i]=$SPEED
        fi

    done < $DUMP_PATH/dump-02.csv
    echo -e "`gettext \"       Select target               \"`"
    read choice
    idlenght=${aidlenght[$choice]}
    ssid=${assid[$choice]}
    channel=${achannel[$choice]}
    mac=${amac[$choice]}
    privacy=${aprivacy[$choice]}
    speed=${aspeed[$choice]}
    Host_IDL=$idlength
    Host_SPEED=$speed
    Host_ENC=$privacy
    Host_MAC=$mac
    Host_CHAN=$channel
    acouper=${#ssid}
    fin=$(($acouper-idlength))
    Host_SSID=${ssid:1:fin}
    execute "Wesside" $WESSIDE -v $Host_MAC -i $wifi & choosewesside
}

diagmenu(){
    while true; do
        mkmenu "Diagnostic tools and reports" "Show kstats report" "Test injection" "Checks with airmon-ng" "Create graphs" "Return to main menu"
        read -p "Select option: " yn; 
        case $yn in
            1  ) kstatsmenu    ; $clear; break;;
            2  ) inject_test   ; $clear; break;;
            3  ) airmoncheck   ; $clear; break;;
            4  ) _airgraph     ; $clear; break;;
            5  )                 $clear; break;;
            *  ) _ "Unknown response, try again"; sleep 1; $clear;;
        esac
    done
}

kstatsmenu(){
    if [ "$Host_MAC" != "" ] && [ "$Host_SSID" != "" ] && [ -e $DUMP_PATH/$Host_MAC.key ]; then
        _ "Converting to ivs"; sleep 0.2
        $IVSTOOLS --convert $DUMP_PATH/$Host_MAC.cap $DUMP_PATH/$Host_MAC.ivs &> /dev/null
        _ "I'm going to print here kstats info"; sleep 1
        $KSTATS $DUMP_PATH/$Host_MAC-01.ivs `cat $DUMP_PATH/$Host_MAC.key`
        read -p "Enter any key to continue" ktc
    else
        $clear; warn "You don't have a cracked WEP interface"; sleep 2; $clear; return
    fi

}

inject_test(){
    execute "Test injection" $AIREPLAY $iwifi --test 
}

airmoncheck(){
    if [ "$TYPE" = "Atherosmadwifi-ng" ]; then $AIRMON check wifi0
    else $AIRMON check $wificard; fi
}

_airgraph(){
    if [ "$Host_MAC" == "" ]; then
        read -p "Enter format (CPG|CAPR): " g
        read -p "Do you want to launch a browser? [y|N] " yn
        execute "Generating graphics" $AIRGRAPH -i $DUMP_PATH/$Host_MAC.csv -o $DUMP_PATH/$Host_MAC.png -g $g
        [ $yn == "y" ] && sensible-browser $DUMP_PATH/$Host_MAC.png
    else $clear; _ "Error: You have to scan for targets first"; fi
}


decrypt(){
    $AIRDECAP $DUMP_PATH/$Host_MAC.cap -w "`cat $DUMP_PATH/$Host_MAC.key`"
    warn "Decrypted packages to $DUMP_PATH/$Host_MAC.cap-dec.cap"
}

menu_options(){
        mkmenu "Airoscript options"  "Select another interface" "Reset selected interface"\
            "Change MAC of interface"  "Enable monitor mode" "Change DUMP_PATH"\
            "Try to configure network" "Return to main menu"

        read -p "Select option: " yn; 
        case $yn in
        1 ) setinterface 1 ; $clear; break ;;
        2 ) cleanup; $clear; break ;;
        3 ) wichchangemac ; $clear; break ;;
        4 ) monmode;$clear ; break ;;
        5 ) changedumppath;$clear; break;;
        6 ) configure;$clear; break;;
        7 ) $clear;break ;;
        * ) _ "Unknown response. Try again" ;;
        esac
}


menu_plugins(){
    mkmenu "External plugins" "${p_menu[@]}"
    read -p "Enter option: " foo; foo=$(( $foo + 1 ))
    echo `echo ${p_menu[$foo]}|sed 's/ /_/g'`
    sleep 10
    `echo ${p_menu[$foo]}|sed 's/ /_/g'` || { _ "Wrong option, try again"; sleep 1; $clear; menu_plugins; }
}


cleanup(){
    killall -9 aireplay-ng airodump-ng &> /dev/null &
    $AIRMON stop $wificard; ifconfig $wificard down
    $clear; sleep 2; $CARDCTL eject; sleep 2; $CARDCTL insert
    ifconfig $wificard up; $AIRMON start $wificard $Host_CHAN
    $iwconfig $wificard
}


changedumppath(){
    OLD_DUMP_PATH=$DUMP_PATH
    read -p "`gettext 'Enter new path: '`" DUMP_PATH
    read -p "`gettext 'Copy data into new folder? (y/N): '`" ACP && [[ "$ACP" = "y" ]] && cp -r $OLD_DUMP_PATH/* $DUMP_PATH/
    read -p "`gettext 'Erase old folder? (y/N): '`" EPF && [[ "$EPF" = "y" ]] && rm -r $OLD_DUMP_PATH
    mkdir -p $DUMP_PATH # If exists, it won't be created again, so we don't lose anything fot this :-)
    clear
}



eassideng(){
     while true; do $clear
        mkmenu "Easside-ng" "Create virtual interface" "Run buddy server" "Return to main menu"
        case $choice in
            1 )
                while true; do $clear
                    read -p "Select buddy IP" buddyip; $clear
                    mkmenu "Choose ap mac " "Choose source mac " "Chosse Source IP " "Choose router ip " "Execute" "Return"; 
                    read -p "Anser: " answer; echo
                    case $choice in
                        1 ) opts=" $opts -v $answer " ;break ;;
                        2 ) opts=" $opts -m $answer " ;break ;;
                        3 ) opts=" $opts -i $answer " ;break ;;
                        4 ) opts=" $opts -r $answer " ;break ;;
                        5 ) execute "Easside-ng" $EASSIDE -s $buddyip -f $wifi $opts ;break ;;
                        6 ) $clear; break ;;
                    esac
                done ;;
            2 ) execute $BUDDY ;;
            3 ) $clear ; break ;;
            * ) $clear; echo  _ "Unknow response, try again"; sleep 2 ;;
        esac
    done
}

airbaseng(){
    # FUCK This tool is quite awesome, too much for a single function... :/ Might be an entire class, but... this is bash.
    # Functional and so on, let's make a hack!
    check_function airbaseng_main || source $path/attacks/airbaseng
    opt=$1; shift;
    airbase_$opt $@;
}


setupairservng(){
	single_question "Do you want to use airserv-ng? [y/N] "
	if [ "$ans" == "y" ]; then
		export wificard=$wifi && single_question "Start a local server? [y/N] "
		if [ "$ans" == "y" ]; then export wifi="127.0.0.1:666" && $AIRSERV -d  $wificard >/dev/null 2>1 &
		else read -p "Enter airserv-ng address [127.0.0.1:666]"
            wifi=$ans
			if [ "$wifi" == "" ]; then export wifi="127.0.0.1:666";fi
		fi
	fi
}
