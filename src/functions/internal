#!/bin/bash
# Internal functions file for airoscript.
# Recommends: wlandecrypter 

# Copyright (C) 2009 David Francos Cuartero
#        This program is free software; you can redistribute it and/or
#        modify it under the terms of the GNU General Public License
#        as published by the Free Software Foundation; either version 2
#        of the License, or (at your option) any later version.

#        This program is distributed in the hope that it will be useful,
#        but WITHOUT ANY WARRANTY; without even the implied warranty of
#        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#        GNU General Public License for more details.

#        You should have received a copy of the GNU General Public License
#        along with this program; if not, write to the Free Software
#        Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

_(){
   a=$1; shift
   echo -en "`gettext \"$a\"` $@"
}

mainmenu(){
    mkmenu "Main Menu" "Attack   - Attack target" "Crack    - Get target key"  "Scan - Manually scan for targets" "Select - Reselect target" "Others   - Various utilities" "Exit    - Quits"
    if [ "$AUTO" == 1 ]; then return; fi
    echo -en "$mark `_ ' Select option: '` "
    set -a choice
    read -a choice

        for choix in ${choice[*]}; do
        case "$choix" in
            1)witchattack;;
            2) if [ "$interactive" == "0" ]; then auto; else witchcrack; fi ;;
            3)choosetype;;
            4)select_ap;;
            5)extramenu;;
            6)doexit;;
            *)$clear && _ 'ERROR: Wrong number entered';;
        esac
        done
    mainmenu
}

rootwarn(){
    li=`tput lines`; cen=`expr $li / 2 + 2`; if [ "$UID" != 0 ]; then $clear;echo -e "\E[3;22H===airoscript-ng===\E[$cen;15H\E[31mYou Must be root to use airoscript\E[39;49;00m\E[$li;20H"; exit 1; fi;
}

setps(){
    $clear
    if [ "$1" != "" ]; then PS3=`_ "$1"`; 
    else PS3=`_ 'Input number: '`; fi
}

_debug(){
    if [ "$debug" == 1 ]; then echo -en $mark; _ $1; fi
}

default_theme(){
    _ '[WARN] : theme file does not exists, using defaults...'
	DUMPING_COLOR="#FFFFFF"; INJECTION_COLOR="#1DFF00"
	ASSOCIATION_COLOR="#FF0009"; DEAUTH_COLOR="#99CCFF"; BACKGROUND_COLOR="#000000"
}

setaircrackpaths(){
	AIRMON=$SBINDIR"airmon-ng"		
	AIRODUMP=$SBINDIR"airodump-ng"
	AIREPLAY=$SBINDIR"aireplay-ng"	
	AIRCRACK=$BINDIR"aircrack-ng"
	ARPFORGE=$BINDIR"packetforge-ng"
	WESSIDE=$SBINDIR"wesside-ng"
	AIRSERV=$SBINDIR"airserv-ng"
	TKIPTUN=$SBINDIR"tkiptun-ng"
    IVSTOOLS=$SBINDIR"ivstools"
    BUDDY=$SBINDIR"buddy-ng"
    EASSIDE=$SBINDIR"easside-ng"
	MACCHANGER=$BINDIR"macchanger"
    AIRGRAPH=$BINDIR"airgraph-ng"
    AIRDECLOAK=$BINDIR"airdecloak-ng"
    KSTATS=$BINDIR"kstats"
	iwconfig="iwconfig"

}

confwarn(){
_ 'Youre going to use a config file on your home or current dir.
This may be harmfull, for example, if your user have been
compromised, and youre getting rights trought sudo, someone
can modify your config file to do something malicious as
root. Be sure to check your home config file before using it.
Defaults on /etc/airoscript-ng.conf should be ok so you can
safely remove your ~/.airoscript-ng.conf\n\n
Do you really want to do it (yes/No): '
}

screen_startup(){
    if [ -O ~/.airoscript-ng/screen_has_started ]; then
        rm ~/.airoscript-ng-ng/screen_has_started
	else
		touch ~/.airoscript-ng/screen_has_started
		screen -S airoscript-ng -c $SCREENRC $0 screen
		$clear && _ 'airoscript-ng is terminating...'; exit
	fi
}

usage(){
cat << eof
usage: $0 options

options:
   -h      show this message
   -t      specify terminal
   -s      use screen interface
   -g      launch graphical interface (requires airosperl)
   -d      debug mode
eof
}

setargs(){
while getopts “ht:s:d” option; do
     case $option in
         h)  usage; exit 1;;
         t)  TERMINAL=$optarg;;
         s)  TERMINAL=screen;;
         g)  TERMINAL=gui;;
         v)  debug=1; hold=1;;
         ?)  usage; exit;;
     esac
done
}

initial_warning(){
	echo -en $mark;
    _ "Airoscript is provided under the gpl.
I'm not responsible of the use anyone can give to airoscript.
Written for educational purpose in mind.
"
sleep $warn_time
}

check_cardctl(){
    if [ `uname -r|cut -d . -f 2` == "6" ]; then CARDCTL="pccardctl"
    else CARDCTL="cardctl"; fi
}

_get_current_reso(){ awk '/\*/ {print $1}' <<< "`xrandr`"; }

_resonset(){
	for i in 640x480 800x480 800x600 1024x600 1024x768 1280x768 1280x800 1280x1024 1600x1200; do 
        reso=`_get_current_reso` ;
        [[ "$i" == $reso ]] && {
             reson=$reso
            echo -e "$mark Automatically setting resolution to $reso";
         }
    done
    if [ "$reson" != "" ]; then export resonset=1; fi
}

execute(){ 
    title=$1; shift;

    if [  "$ADDOPTIONS" != "" ]; then
        printf -- "Executing $@"
        echo
        read -p "Enter extra options to execute: " eopts
    fi

    if [ $TERMINAL == "screen" ]; then
		$CDCMD screen -S airoscript -c $SCREENRC -D -RR -X screen -t $title
		$CDCMD screen -S airoscript -c $SCREENRC -X at "*" stuff "${@} $eopts" 
    else
        HOLDA=$HOLD
        if [ "$1" == "crack" ]; then HOLDA="-hold"; shift; fi # FIXME This will work just on xterm.
        if [ "$QUIET" != "" ] || [ "$AUTO" == "1" ]; then 
            echo -ne $mark $title...
            ${@} $eopts &> /dev/null &
        else
            $CDCMD $TERMINAL $HOLDA $TITLEFLAG "$title" $TOPLEFTBIG $BGC $BACKGROUND_COLOR $FGC $DUMPING_COLOR $EXECFLAG "${@} $eopts" &
        fi
    fi 
    save_pids $!
}

save_pids(){
    mkdir /var/run/airoscript 2>/dev/null
    for i in `get_childs $1`; do touch "/var/run/airoscript/$i"; done
}

get_childs(){ 
    ps axo ppid,pid|awk "/$1/ {print \$2}"|grep -v "$pid" 
}
clean_processes(){ 
    for i in `ls /var/run/airoscript/`; do kill -2 $i; rm /var/run/airoscript/$i; done; 
    }

arrow(){ 
    return
#    echo -e -n "\t\n||\t\n||\t\n\/";
}
fill_menu(){
    len=$(( $1 - $2 )); for i in `seq 0 $len`; do echo -n "$3"; done; 
}
fill(){
    menu_w="$3"; separator="$2"; title="$1"; len_1=$((${#title} + 3))
    half_len_1=$(( $len_1 / 2 )) ; loop_times=$(( $menu_w / 2 - $half_len_1 ))
    fill_menu $loop_times 1 "$separator";echo -n "$title";fill_menu $loop_times 1 "$separator"
}

function mkbox(){   
     echo -n "+"; fill "$menu_t" "$separator_h" "$(( $max + ${#menu_t} ))" center; echo "+"
}

temporary_switch_clear(){ foo="$oldclear"; oldclear=$clear; clear=$foo; } 
vline(){ for i in `seq 0 $1`; do echo -n "-"; done; }
mkmenuline(){ echo -en "$separator_x"; for i in $(seq 1 $1); do echo -en "$separator_h"; done; echo "$separator_x"; }   
mkmenuheader(){ echo -en "\033[$(($2 / 2 - (${#1} / 2 - 10) ))C$1\n"; }
getmaxlenfromlist(){ max=0; for i in "${@}"; do [[ ${#i} -gt $max ]] && max=${#i}; done; echo $max; }
mkmenueline(){ echo -en "${separator_v}\033[${1}C${separator_v}\033[${1}D${white}${2}${red})${end} ${separator_v}";}
mkmenulines(){ max=$1; shift; for i in "${@}"; do line=$(( line + 1 )); mkmenueline $max $line; echo " $i"; done; }

mkmenu(){
    max=`getmaxlenfromlist "${@}"`
    max=$(( $max + 10 ))
    title=$1; shift; line=0;
    f=$((`tput cols` - 10)); 
    mkmenuheader $title $max
    mkmenuline $max
    mkmenulines $max "${@}"
    mkmenuline $max
}

monmode(){ ifconfig $1 up; $iwconfig $1 |grep "Monitor" && if [ $? != 0 ]; then MON_PREFIX=$mon_prefix $AIRMON start $1 $2; fi;}
reso() {
        _resonset
	while true; do
		if [ "$resonset" = "" ]; then mkmenu "$resonset" "Resolution" "640x480" "800x480" "800x600" "1024x768" "1280x768" "1280x800" "1280x1024" "1600x1200"; read -p "Select resolution: " reson; fi
        { echo $reson| grep "x"; } &>/dev/null && {
            case $reson in
                "640x480") reson=1;;
                "800x480") reson=2;;
                "800x600") reson=3;;
                "1024x600") reson=4;;
                "1024x768") reson=5;;
                "1280x768") reson=6 ;;
                "1280x800") reson=7;;
                "1280x1024") reson=8;;
                "1600x1200") reson=9;;
            esac
        }
		case $reson in
			1 ) TLX="83";TLY="11";TRX="60";TRY="18";BLX="75";BLY="18";
                BRX="27";BRY="17";bLX="100";bLY="30";bRX="54";bRY="25"; setterminal; break;;
			2 ) TLX="90";TLY="11";TRX="60";TRY="18";BLX="78";BLY="26";
                BRX="52";BRY="15";bLX="130";bLY="30";bRX="78";bRY="25"; setterminal; break;;
			3 ) TLX="92";TLY="11";TRX="68";TRY="25";BLX="78";BLY="26";
                BRX="52";BRY="15";bLX="92" ;bLY="39";bRX="78";bRY="24"; setterminal; break;;
			4 ) TLX="92";TLY="14";TRX="68";TRY="25";BLX="92";BLY="36";
                BRX="74";BRY="20";bLX="100";bLY="52";bRX="54";bRY="25"; setterminal; break;;
			5 ) TLX="92";TLY="14";TRX="68";TRY="25";BLX="92";BLY="36";
                BRX="74";BRY="20";bLX="100";bLY="52";bRX="54";bRY="25"; setterminal; break;;

			6 ) TLX="100";TLY="20";TRX="109";TRY="20";BLX="100";BLY="30";
                BRX="109";BRY="20";bLX="100";bLY="52";bRX="109";bRY="30"; setterminal; break;;
			7 ) TLX="100";TLY="20";TRX="109";TRY="20";BLX="100";BLY="30";
                BRX="109";BRY="20";bLX="100";bLY="52";bRX="109";bRY="30"; setterminal; break;;
			8 ) TLX="110";TLY="35";TRX="99";TRY="40";BLX="110";BLY="35";
                BRX="99";BRY="30";bLX="110";bLY="72";bRX="99";bRY="40"; setterminal; break;;
			9 ) TLX="130";TLY="40";TRX="68";TRY="25";BLX="130";BLY="40";
                BRX="132";BRY="35";bLX="130";bLY="85";bRX="132";bRY="48"; setterminal; break;;
			* ) _ "Unknown response. Try again"; sleep 1; $clear ;;
		esac
	done
}

function setterminal {
	getterminal
	_debug "Im going to set terminal options for your terminal now"

    case $TERMINAL in 
		xterm|uxterm ) 
			TOPLEFT="-geometry $TLX*$TLY+0+0 "
			TOPRIGHT="-geometry $TRX*$TRY-0+0 "
			BOTTOMLEFT="-geometry $BLX*$BLY+0-0 "
			BOTTOMRIGHT="-geometry $BRX*$BRY-0-0 "
			TOPLEFTBIG="-geometry $bLX*$bLY+0+0 "
			TOPRIGHTBIG="-geometry $bLX*$bLY+0-0 "
			HOLDFLAG="-hold"
			TITLEFLAG="-T"
			FGC="-fg"
			BGC="-bg"
			EXECFLAG="-e"
            ;;
		gnome-terminal|gnome-terminal.wrapper ) 
			TOPLEFT="-geometry=$TLX*$TLY+0+0 "
			TOPRIGHT="-geometry=$TRX*$TRY-0+0 "
			BOTTOMLEFT="-geometry=$BLX*$BLY+0-0 "
			BOTTOMRIGHT="-geometry=$BRX*$BRY-0-0 "
			TOPLEFTBIG="-geometry=$bLX*$bLY+0+0 "
			TOPRIGHTBIG="-geometry=$bLX*$bLY+0-0 "
			EXECFLAG="-e "
			HOLDFLAG="" 
			TITLEFLAG="-t"
			FGC=""
			DUMPING_COLOR=""
			INJECTION_COLOR=""
			ASSOCIATION_COLOR=""
			DEAUTH_COLOR=""
			BACKGROUND_COLOR=""
			BGC=""
            ;;

		airosperl ) airosperl & exit ;;
		gui ) airosperl & exit ;;
	esac
    [[ "$debug" = "1" ]] && echo $TOPLEFT \
				$TOPRIGHT \
				$BOTTOMLEFT \
				$BOTTOMRIGHT \
				$TOPLEFTBIG \
				$TOPRIGHTBIG \
				$HOLDFLAG\
				$TITLEFLAG\
				$FGC\
			    $BGC\
				printf -- "$EXECFLAG \n"
}


# this function allows debugging, called from main menu.
function debug {
	if [ "$debug" == "1" ] || [ "$hold" == "1"  ]; then
		export HOLD=$HOLDFLAG; _ "Debug Mode enabled, you'll have to manually close windows"
	else export HOLD="" ;fi
}

getterminal(){
    [[ "$TERMINAL" = "GUI" ]] && TERMINAL="airosperl"
    if [ -x $TERMBIN/$TERMINAL ]; then
	    _debug "Using configured terminal"
	else
		_debug "$TERMINAL was not used, not found on path"
		_debug "Using default terminal"
			TERMINAL=`ls -l1 /etc/alternatives/x-terminal-emulator|cut -d ">" -f 2|cut -d " " -f 2|head -n1`;        
	fi

	if [ -x "$TERMBIN/$TERMINAL" ] || [ -x "/usr/bin/$TERMINAL" ] || [ -x "/usr/sbin/$TERMINAL" ]; then D="1" 
	else
        if [ -e $TERM ]; then 
		    _debug "Using environment defined terminal ($TERM)"
			TERMINAL=$TERM
		else
            if [ -x "$TERMBIN/xterm" ]; then
				TERMINAL="xterm" && _debug "Using Xterm"
			else
			_   "I cant find any good terminal, please set one on your conffile
				Your TERMINAL var contains no valid temrinal
				Your alternative against x-terminal-emulator contains no terminal
				Xterm can\'t be found on your system, Maybe not in /usr/bin?"
				exit
			fi
		fi     
	fi
}

select_ap(){
		if [ -e $DUMP_PATH/dump-01.csv ]; then
			selectAp; $clear
			if [ "$Host_SSID" = $'\r' ]; then blankssid;
			elif [ "$Host_SSID" = "No SSID has been detected" ]; then blankssid; fi
			choosetarget; $clear
		else $clear && _ 'ERROR: You have to scan for targets first'; fi
}

deconfigure(){
    airmon-ng stop $WIFI &> /dev/null
    ifconfig $WIFI down
}

delete_dpath(){
	rm -r $DUMP_PATH 2>/dev/null
}

doexit(){
		_ "Do you want me to stop monitor mode on $WIFI? (y/N) "
		read dis; if [ "$dis" = "y" ]; then
			_ 'Deconfiguring interface...'; deconfigure
		fi

		_ 'Do you want me to delete temporary data dir? (y/N) ';
		read del; if [ "$del" = "y" ]; then
			echo -n `gettext 'Deleting'` " $DUMP_PATH ... "; delete_dpath
		fi
		exit

}

function hardclean(){ rm -rf $DUMP_PATH/$Host_MAC*; }

checkdir(){
    if [ -d $DUMP_PATH ]; then
        if [ "$DEBUG" == 1 ]; then
            _ "[INFO] Output folder is" " $DUMP_PATH";
        fi
    else
        _ "[Error] Output folder does not exists or is a regular file."
        exit
    fi
}
