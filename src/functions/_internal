# Internal functions file for airoscript.
# Recommends: wlandecrypter

# Copyright (C) 2009-2011 David Francos Cuartero
#        This program is free software; you can redistribute it and/or
#        modify it under the terms of the GNU General Public License
#        as published by the Free Software Foundation; either version 2
#        of the License, or (at your option) any later version.

#        This program is distributed in the hope that it will be useful,
#        but WITHOUT ANY WARRANTY; without even the implied warranty of
#        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#        GNU General Public License for more details.

#        You should have received a copy of the GNU General Public License
#        along with this program; if not, write to the Free Software
#        Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


cleanautovars(){
    export AUTO=0; export QUIET=""; export INTERACTIVE=$OLDINTERACTIVE
    return
}

configure(){
    if [ -O $DUMP_PATH/$Host_MAC.key ] && [ "$Host_MAC" != "" ]; then
        warn "${mark}Configuring network"
        KEY="$(cat $DUMP_PATH/$Host_MAC.key)"
        tag;warn "${mark}Got key: $KEY"
        [[ "$Host_ENC" =~ (.*)WPA(.*) ]] && {
            tag;warn "${mark}Configuring wpa_supplicant"
            wpa_passphrase $Host_SSID "$KEY" > $DUMP_PATH/$Host_MAC.wpa_supplicant;
            wpa_supplicant -i $wificard -B -c$DUMP_PATH/$Host_MAC.wpa_supplicant;
            tag; warn "${mark}Launching $DHCPSOFT to $wificard"
            $DHCPSOFT $wificard &>/dev/null || warn "${mark}Could not autoconfigure network"
        } || {
            tag; warn "${mark}Configuring network with iwconfig"
            $iwconfig $wificard essid $Host_SSID channel $Host_CHAN key $KEY &>/dev/null && {
            tag; warn "${mark}Launching $DHCPSOFT to $wificard"
                $DHCPSOFT $wificard &>/dev/null || warn  "${mark}Could not autoconfigure network" && return 2
            } || { warn "${mark}Could not autoconfigure network, wrong password size?"; }
        }
    else
        warn "You haven't cracked this network yet"; sleep 3; $clear
    fi
}

usage(){
    cat << eof
usage: $0 [-h] [-t TERMINAL] [-s] [-v] [-m] [-c] [-x] [-n FILTER] [-w WIFICARD] [-f] [-a]

options:
   -h      Show this message
   -t      Specify terminal
   -s      Use screen interface
   -v      Verbose & debug mode
   -w      Specify wifi card
   -v      Writes a csv file with network data.
   -f      Change mac to fakemac before everything else.
   -c      Change FAKE_MAC to use real mac
   -m      Start monitor mode witout caring for mac
   -a      Automatic mode
           -n  Filter SSID by regex (for automatic mode)
   -x      Autoconfigure network after automatic crack (requires -a)
   -z      Don't scan automatically at start

NOTE: -a must allways be the lastest option provided.
eof
}

setargs(){
     while getopts “bn:ht:w:szxcvmfap:” option; do
        case $option in 
            h)  usage; exit 1;;
            n)  export filter_ssid=$OPTARG; warn "${mark}Selected filter: $filter_ssid";;
            t)  TERMINAL=$OPTARG;;
            b)  report_mode=1;;
            s)  TERMINAL=screen;;
            z)  noscan=1;;
            v)  export debug=1; export hold=1; _source "./airoscript-ng_debug.conf ~/airoscript-ng_debug.conf /etc/airoscript-ng_debug.conf /usr/local/etc/airoscript-ng_debug.conf" ;;
            w)  wificard=$OPTARG;;
            x)  export options_autoconfigure=1;;
            m) { guess_idata "start"; testmac; export iwifi=$wifi ; } &>/dev/null; warn "${mark}Monitor interface setup correctly $iwifi $wifi $wificard..."; sleep 1; set_wifi_by_args=1;;
            c)  checkforcemac 3;
                { guess_idata "start"; testmac; export iwifi=$wifi ; } &>/dev/null; 
                warn "${mark}Monitor interface setup correctly $iwifi $wifi $wificard..."; 
                sleep 1; set_wifi_by_args=1;;
            f)  wichchangemac 1;
                { guess_idata "start"; testmac; export iwifi=$wifi ; } &>/dev/null;
                warn "${mark}Monitor interface setup correctly $iwifi $wifi $wificard...";
                sleep 1; set_wifi_by_args=1 ;;
            a)  noscan=1; temporary_switch_clear;clear="";
                check_function doauto || source $path/autocrack;
                doauto;
                exit;;
            p)  load_plugins $OPTARG  ;;
            ?)  usage; exit;;
        esac
    done
}

load_plugins(){
    for i in "${@}"; do 
        if [ -e $path/plugins/$i ]; then
            _source $path/plugins/$i
        fi
    done
}

initial_warning(){
	warn -en $mark;
    _ "  Airoscript is provided under the gpl.
I'm not responsible of the use anyone can give to airoscript.
Written for educational purpose in mind.
"
sleep $warn_time
}

# Standard functions.


_debug(){
    if [ "$debug" == 1 ]; then echo -en $mark; _ $1; fi
}

execute(){ 
    source $path/interface
    check_function save_pids || source $path/internal/childs
    title=$1; shift;

    if [  "$ADDOPTIONS" != "" ]; then
        printf -- "Executing $@"
        echo
        read -p "Enter extra options to execute: " eopts
    fi

    if [ $TERMINAL == "screen" ]; then
		$CDCMD screen -S airoscript -c $SCREENRC -D -RR -X screen -t $title
		$CDCMD screen -S airoscript -c $SCREENRC -X at "*" stuff "${@} $eopts" 
    else
        if [ "$1" == "crack" ]; then HOLDA="-hold"; shift; fi # FIXME This will work just on xterm.
        if [ "$QUIET" != "" ] || [ "$AUTO" == "1" ]; then 
            warn ${mark}$title
            if [[ $wait_for_execute ]]; then
                ${@} $eopts &> /dev/null
            else
                ${@} $eopts &> /dev/null &
            fi
        else
            [[ $wait_for_execute == 1 ]] && {
                $CDCMD $TERMINAL $HOLDA $TITLEFLAG "$title" $TOPLEFTBIG $BGC $BACKGROUND_COLOR $FGC $DUMPING_COLOR $EXECFLAG "${@} $eopts"
            } || {
                $CDCMD $TERMINAL $HOLDA $TITLEFLAG "$title" $TOPLEFTBIG $BGC $BACKGROUND_COLOR $FGC $DUMPING_COLOR $EXECFLAG "${@} $eopts" &
            }
        fi
    fi 
    save_pids $!
}

monmode(){ ifconfig $1 up; $iwconfig $1 |grep "Monitor" && if [ $? != 0 ]; then MON_PREFIX=$mon_prefix $AIRMON start $1 $2; fi;}

# this function allows debugging, called from main menu.
function debug {
	if [ "$debug" == "1" ] || [ "$hold" == "1"  ]; then
		export HOLD=$HOLDFLAG; _ "Debug Mode enabled, you'll have to manually close windows"
	else export HOLD="" ;fi
}

_read(){
    # Read function so we can override it later, to add another interface.
    read "${@}"; 
}

# Various checks.
checkdir(){
    if [ -d $DUMP_PATH ]; then
        if [ "$DEBUG" == 1 ]; then
            _ "[INFO] Output folder is" " $DUMP_PATH";
        fi
    else
        _ "[Error] Output folder does not exists or is a regular file."
        exit
    fi
}

check_function(){
    declare -f $1 &>/dev/null
    return $?
}

# Standard attacks functions.

attack_wpa(){
    check_function wpa_attacks || source $path/attacks/wpa
    wpa_attacks menu
}

attack_wep(){
    check_function wep_attacks || source $path/attacks/wep
    wep_attacks menu
}

attack_opn(){ # If no encryption detected
    if [ "$Host_SSID" = "" ]; then
        $clear &&  echo  "`gettext 'ERROR: You have to select a target'`"
    else
        $clear && echo `gettext "ERROR: Network not encrypted or no network selected "`
    fi
}

capture(){
    hardclean
    execute "Capturing" $AIRODUMP --ignore-negative-one --bssid $Host_MAC -w $DUMP_PATH/$Host_MAC -c $Host_CHAN -a $wifi 
    echo
}

tag(){ echo -ne "\t"; }

hardclean(){ rm -rf $DUMP_PATH/$Host_MAC*; }

single_question(){ read -p "${@}" ans; }
warn(){ echo "${@}"; }
specialwarn(){ echo -e -n "${@}"; }
yesno(){
    read -p "${@} [Y|n]" -n1 -s a; echo
    [[ $a =~ (.*)[N|n](.*) ]] && return 1 || return 0
}
_source $path/internal/startup
